
初始化流程


Vue是如何编译模板的,如何编译成虚拟DOM，如果更新到页面？

字符串模板
单文件组件

模板内容：
元素
  nodeType
    元素结点
    属性结点
      属性
      指令
      事件
    注释结点
    文本结点
组件

字符串模板  -> AST  ->  runtime code
                  -> vnode
通过patch更新到dom

Vue获取模板字符串通过循环的方式进行字符串截取进行匹配的方式进行解析，每一个模板内容元素都有对应的解析器，元素解析器，文本解析器，注释解析器，属性解析器；  比如通过截取判断第一个字符是否是"<"来调用元素解析器;
当模板字符串截取解析完毕最终生成抽象语法树，通过generate方法对AST生成执行代码；最后通过patch方法渲染到浏览器； 


@vue/compiler-core/compile.ts
译成成AST,对AST转成可执行代码，对parse,codegen进行调度


@vue/compiler-core/parse.ts
模块编译的核心文件，主要通过parseChildren进行解析


@vue/compiler-core/codegen.ts
主要对AST转换成执行代码


@vue/runtime-dom/index.ts
createApp的文件，创建app入口文件；



如果处理事件，属性，指令的
如果处理虚拟DOM,如何做虚拟DOM和真实DOM的diff
如果处理数据响应式
如何处理组件


初始化

registerRuntimeCompiler(@vue) ->
  compileToFunction(@vue) ->
    compile(@vue/compiler-dom) ->
      baseCompile(@vue/compiler-core) ->
        baseParse(@compiler-core/parse) ->
          parseChildren(parse) ->
            循环解析模板字符串
        generate() ->
          createCodegenContext()


{
  type: NodeTypes.ROOT,
  children,
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc: {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  }
}



Vue.createApp()

createApp(runtime-dom) ->
  ensureRenderer(runtime-dom) ->
    createRenderer(@vue/runtime-core) ->
      baseCreateRenderer(@vue/runtime-core/renderer.ts)
        createAppAPI(./apiCreateApp)
        app.mount() ->
          normalizeContainer()
          mount() -> 
            createVNode()
            render() -> 
              patch() -> 
                processElement() -> 
                  mountElement() ->
                    mountChildren() -> 
                      patch()
                  patchElement()
                processComponent() -> 
                  mountComponent() ->
                    setupStatefulComponent() ->
                      setupComponent() ->
                        finishComponentSetup()(runtime-dom)  -> 
                          compileToFunction() ->
                            compile(@vue/compiler-dom) ->
                              baseCompile(@vue/compiler-core/compiler) ->
                                baseParse(@compiler-core/parse) ->
                                  parseChildren(parse) ->
                                    parseInterpolation()
                                    parseComment()
                                    parseCDATA()
                                    parseBogusComment()
                                    parseTag()
                                      parseAttributes()
                                        parseAttribute
                                    parseElement()
                                      parseTag()
                                      parseAttributes()
                                        parseAttribute
                                    parseText()
                                generate() ->
                                  createCodegenContext()




Vue的双向数据绑定原理是怎么样的？
ref

ref -> createRef -> new RefImpl(rawValue, shallow)  ->  convert   ->  track
                                                                      trigger

ref 如果参数是对象则调用reactive