
初始化流程

Vue是如何编译模板的,如何编译成虚拟DOM，如果更新到页面？
如何处理事件，属性，指令的？
如何处理虚拟DOM,如何做虚拟DOM和真实DOM的diff？
如何处理数据响应式？
如何处理组件？



字符串模板
单文件组件

模板内容：
元素
  nodeType
    元素结点
    属性结点
      属性
      指令
      事件
    注释结点
    文本结点
组件

字符串模板  -> AST  ->  runtime code
                  -> vnode
通过patch更新到dom

Vue获取模板字符串通过循环的方式进行字符串截取进行匹配的方式进行解析，每一个模板内容元素都有对应的解析器，元素解析器，文本解析器，注释解析器，属性解析器；  比如通过截取判断第一个字符是否是"<"来调用元素解析器;
当模板字符串截取解析完毕最终生成抽象语法树，通过generate方法对AST生成执行代码；最后通过patch方法渲染到浏览器； 


@vue/compiler-core/compile.ts
译成成AST,对AST转成可执行代码，对parse,codegen进行调度


@vue/compiler-core/parse.ts
模块编译的核心文件，主要通过parseChildren进行解析


@vue/compiler-core/codegen.ts
主要对AST转换成执行代码


@vue/runtime-dom/index.ts
createApp的文件，创建app入口文件；使用@vue/runtime-core/renderer.ts的createRenderer()方法返回的createApp

通过参数注入DOM操作方法
function ensureRenderer() {
  return renderer || (renderer = createRenderer<Node, Element>(rendererOptions))
}


insert: hostInsert,
remove: hostRemove,
patchProp: hostPatchProp,
forcePatchProp: hostForcePatchProp,
createElement: hostCreateElement,
createText: hostCreateText,
createComment: hostCreateComment,
setText: hostSetText,
setElementText: hostSetElementText,
parentNode: hostParentNode,
nextSibling: hostNextSibling,
setScopeId: hostSetScopeId = NOOP,
cloneNode: hostCloneNode,
insertStaticContent: hostInsertStaticContent


@vue/runtime-core/index.ts
导出方法入口文件

@vue/runtime-core/renderer.ts
渲染的核心文件之一

核心方法baseCreateRenderer，接收一个RendererOptions的参数，RendererOptions包括一些操作原生DOM的API，

createAppAPI 返回实例方法，如：use, mixin, component

processText
processCommentNode
processElement
processFragment
processComponent

mountStaticNode
mountElement
mountChildren
mountComponent

updateComponentPreRender
updateComponent

setupRenderEffect
setScopeId

patch
patchStaticNode
patchElement
patchBlockChildren
patchProps
patchChildren
patchUnkeyedChildren
patchKeyedChildren

move
moveStaticNode

remove
removeStaticNode
removeFragment

unmount
unmountComponent
unmountChildren

getNextHostNode

render


初始化

registerRuntimeCompiler(@vue) ->
  compileToFunction(@vue) ->
    compile(@vue/compiler-dom) ->
      baseCompile(@vue/compiler-core) ->
        baseParse(@compiler-core/parse) ->
          parseChildren(parse) ->
            循环解析模板字符串
        generate() ->
          createCodegenContext()


{
  type: NodeTypes.ROOT,
  children,
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc: {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  }
}


当程序加载的时候compileToFunction会通过registerRuntimeCompiler方法被注入到@runtime-core/component.ts的compile上，当调用createApp的过程中会调用compile
使用注入的好处：
可以实现解藕，在不同场景下可以注入不同的对象，方法； 在vue @vue/index和@vue/vue-compat里通过registerRuntimeCompiler注入了不同处理的方法


Vue.createApp()

createApp(@vue/runtime-dom/index) ->
  ensureRenderer(@vue/runtime-dom) ->
    createRenderer(@vue/runtime-core) ->
      baseCreateRenderer(@vue/runtime-core/renderer.ts)
        createAppAPI(./apiCreateApp)
        app.mount() ->
          normalizeContainer()
          mount() -> 
            createVNode()
            render() -> 
              patch() -> 
                processText() ->
                processCommentNode() ->
                processElement() -> 
                  mountElement() ->
                    mountChildren() -> 
                      patch()
                  patchElement()
                processComponent() -> 
                  mountComponent() ->
                    setupStatefulComponent() ->
                      setupComponent() ->
                        finishComponentSetup()(@vue/runtime-dom)  -> 
                          compileToFunction() ->
                            compile(@vue/compiler-dom) ->
                              baseCompile(@vue/compiler-core/compiler) ->
                                baseParse(@compiler-core/parse) ->
                                  parseChildren(parse) ->
                                    parseInterpolation()
                                    parseComment()
                                    parseCDATA()
                                    parseBogusComment()
                                    parseTag()
                                      parseAttributes()
                                        parseAttribute
                                    parseElement()
                                      parseTag()
                                      parseAttributes()
                                        parseAttribute
                                    parseText()
                                generate() ->
                                  createCodegenContext()




Vue的双向数据绑定原理是怎么样的？
ref

ref -> createRef -> new RefImpl(rawValue, shallow)  ->  convert   ->  track
                                                                      trigger

ref 如果参数是对象则调用reactive


当对ref或reactive包装的数据进行赋值的时候会触发set拦截，在set拦截里通过trigger触发副作用
触发patch进行DOM比较看是否需要更新，虚拟DOM和实体DOM有一个映射，当数据变了的时候先跟之前的虚拟DOM
进行比较如果不一样则通过原生DOM操作API更新真实DOM